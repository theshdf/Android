#### Java中的并发主要是线程和多线程的问题

#### 单线程中，线程同步效率低的原因？
Java当中多个线程之间是不能互相传递数据通信的,多线程之间的通信只能通过共享变量来完成.而JVM当中存在一个所有线程都共享的内存区域,称为主存,当我们new一个对象的时候,该对象将会放置到JVM主存当中,而每个线程他们都有各自独立的工作空间,在多线程环境下,每个线程操作某个对象时,会从主存当中获取对象然后生成副本放置在各自的工作空间当中. 
![图](http://o86ou4qz3.bkt.clouddn.com/thread.gif)

当操作对象时,线程首先会检查工作区间是否拥有对象的副本,若然没有,则读取主存生成副本,若拥有副本则直接对读取副本,然后对对象进行修改,然后同步到主存当中,由于多线程的执行顺序是不能确定的,取决于CPU,所以可能出现两条线程同时在主存获取到副本,对各自的副本进行修改先后提交导致错误数据出现的情况,而解决这个问题就要使用synchronized同步机制. 
![](http://o86ou4qz3.bkt.clouddn.com/thread2.gif)
 在使用同步时,我们都知道只有一条线程能进入到已同步的逻辑当中,那为什么会影响效率?其实是一个很简单的道理.在不同步的状态下线程同副本中获取,就好比一个在旁边顺手拿东西,而在同步下,需要到JVM中的主存来获取,好比一个攀山涉水的过程,因为需要从主存当中重新获取主存中对象最新的信息,然后对其修改,提交回主存当中,而且申请锁是要会占用系统资源,所以这才是导致同步操作效率低的情况发生. 
#### 多线程中，线程同步效率低的原因?

#### Java并发的特性
1. 原子性 多个线程同时执行的时候，一个操作一旦开始，就不会被其他线程干扰.加同步可以
2. 有序性 保证程序执行的顺序按照代码的  先后顺序执行  加同步可以保证代码执行的顺序，但是不能保证指令的执行顺序，在java内存模型中是允许编译器和处理器对指令进行重排序的，重排序对单线程没有影响，但是对于多线程会影响其正确性。需要通过volatile保证指令的正确性
>比如创建对象的过程：1 memory=allocate();// 分配内存 相当于c的malloc2 ctorInstanc(memory) //初始化对象3 instance=memory //设置instance指向刚分配的地址。上面的代码在编译器运行时，可能会出现重排序 从1-2-3 排序为1-3-2

1. 可见性 多个线程共同访问同一个变量时，一个线程修改了该变量，其他线程也能立刻看到修改的值，用volatile来修饰

